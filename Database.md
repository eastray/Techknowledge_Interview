# Database

### index

- DBMS
- DBMS 장점
- DBMS 단점
- DBMS 언어
- DBMS 사용자
- 관계 데이터 모델의 개념
- 릴레이션 특징
- 릴레이션 키
- 무결성 제약조건
- 조인 연산자
- SQL
- 인덱스
- 릴레이션 정규화
- ref


-----

## DBMS

DBMS는 사용자가 새로운 데이터베이스를 생성하고, 데이터베이스의 구조를 명시할 수 있게 하고, 사용자가 데이터를 효율적으로 질의하고 수정 할 수 있도록 하며, 시스템의 고장이나 권한이 없는 사용자로부터 데이터를 안전하게 보호하며, 동시에 여러 사용자가 데이터베이스를 접근하는 것을 제어하는 소프트웨어 패키지이다. DBMS는 사용자와 응용 프로그램에게 편리하고 효율적인 데이터베이스 사용 환경을 제공한다.

데이터베이스의 정보 관리를 중앙 집중화함으로써 여러 사용자와 응용 프로그램들이 데이터베이스를 공유한다. 여러 사용자에 적합한 다양한 인터페이스를 제공하고, 데이터 간의 복잡한 관계를 표현하며, 무결성 제약조건을 DBMS가 자동적으로 유지한다. 프로그램에 영향을 주지 않으면서 데이터베이스 구조를 변경할 수 있고, 데이터베이스에 영향을 미치지 않으면서 응용 프로그램을 수정할 수 있다. 이를 프로그램-데이터 독립성 (Program-Data Independence)라 한다.

### DBMS 장점

중복성을 최소화하여 통합 데이터베이스를 구축하며 데이터에 대한 모든 접근은 효과적으로 데이터를 처리하는 DBMS를 통해 이루어진다.  데이터 독립성은 데이터 구조에 어떤 변경이 있어도 프로그램을 수정할 필요 없이 계속해서 사용할수 있기 때문에 중요하다. DBMS의 장점은 아래와 같다.

- 중복성과 불일치 감소
  - DBMS를 사용한다고 해서 중복성이 완전히 제거되는 것은 아니지만 데이터베이스 설계자 또는 응용 프로그램 개발자가 중복성의 유형과 정도를 신중하게 제어할 수 있다
- 사용자를 위한 다양한 서비스 제공
  - 데이터베이스에 데이터가 통합됨으로써 사용자는 보다 쉽게 새롭고 통합된 정보를 얻을 수 있다.
- 프로그램-데이터 독립성 향상
- 시스템 개발 유지 비용 감소
  - 데이터베이스 구축의 초기 비용은 클 수 있으나, 전체적인 유지 비용 면에서는 적다.
- 표준화 시행
- 보안성 향상
  - 레코드와 같은 세밀한 수준에서 검색, 갱신 등의 데이터 수정 권한을 사용자에게 부여할 수 있다.
- 무결성 향상
  - 아무런 조치없이 다수의 사용자가 동시에 동일한 데이터를 갱신하는 것이 허용된다면 데이터베이스의 갱신 결과는 원래 의도한 바와 완전히 달라질 가능성이 있다.
  - 모든 데이터의 관리를 DBMS가 맡기 때문에 무결성을 유지하는 것이 용이하다.
- 요구 사항 식별 용이
  - 데이터베이스가 중앙 집중식으로 구축되면 조직체의 요구사항을 식별하여 충돌되는 요구사항의 균형을 이루는 것이 필요하다.
- 데이터베이스 복구
  - 시스템이 고장나는 경우에 고장나기 이전의 일관된 데이터베이스 상태를 복구할 수 있다.
- 데이터베이스 공유 및 동시 접근
- 다양한 도구 활용



### DBMS 단점

DBMS가 많은 장점을 가지고 있지만, 단점 또한 가지고 있다. DBMS를 무조건 사용해야 하는 것은 아니므로 업무의 요구사항을 잘 파악하여 DBMS 사용 여부를 결정해야 한다.

- 하드웨어 구입 비용 소모
- 데이터베이스 분야의 기술 및 지식 요구
- 응답 시간으로 인한 자원 소모
- 백업 및 회복의 복잡도 높음



### DBMS 언어

데이터베이스를 구축하기 위해서 사용자는 데이터베이스 스키마를 정의한 후 DBMS에서 제공하는 연산자들을 사용해 데이터를 저장, 검색, 수정, 삭제하게 된다. 일반적으로 DBMS는 이와 같은 작업을 용이하게 하는 언어들을 제공한다.

- 데이터 정의어 (DDL: Data Definition Language)

  사용자는 데이터 정의어를 사용하여 데이터베이스 스키마를 정의한다. 데이터 정의어로 명시된 문장이 입력되면 DBMS는 사용자가 정의한 스키마에 대한 명세를 시스템 카탈로그 또는 데이터 사전에 저장한다. 시스템 카탈로그는 메타 데이터를 저장한다. 메타 데이터는 데이터베이스에 저장된 데이터에 관한 데이터를 의미한다.

  - CREATE TABLE: 데이터 구조 생성
  - ALTER TABLE: 데이터 구조 변경
  - DROP TABLE: 데이터 구조 삭제
  - CREATE INDEX: 특정 애트리뷰트 위에 인덱스 정의

- 데이터 조작어 (DML: Data Manipulation Language)

  사용자는 데이터 조작어를 사용하여 데이터베이스 내의 원하는 데이터를 검색하고, 수정하고, 삽입하고, 삭제한다. 일반적으로데이터 조작어에는 어떤 데이터가 필요하고 어떻게 데이터를 찾을 것인가를 명시하는 절차적 언어(Procedural Language)와 어떤 데이터를 원하는가만 명시하고 데이터를 검색하는 방법은 명시하지 않는 비절차적 언어(Non-Procedural Language)가 있다. 관계 DBMS에서 사용되는 SQL은 비절차적 언어이다. 대부분의 데이터 조작어는 SUM, COUNT, AVG와 같은 내장 함수들을 갖고 있다.

  - SELECT: 데이터 검색
  - UPDATE: 데이터 수정
  - DELETE: 데이터 삭제
  - INSERT: 데이터 삽입

- 데이터 제어어 (DCL: Data Control Language)

  사용자는 데이터 제어어를 사용하여 데이터베이스 트랜잭션을 명시하고 권한을 부여하거나 취소한다.



### DBMS 사용자

- 데이터베이스 관리자 (DBA: Database Administrator)

  조직의 여러 부분의 상이한 요구를 만족시키기 위해서 일관성 있는 데이터베이스 스키마를 생성하고 유지하는 사람을 말한다. 관리자는 데이터베이스 스키마 생성 및 변경, 적재(Bulk Loading), 무결성 제약조건 명시, 사용자 권한 부여 및 역할 관리, 저장 구조 및 접근 방법 정의, 백업 및 회복 등의 업무를 담당한다. 

- 응용 프로그래머 (Application Programmer)

- 최종 사용자 (End User)

- 데이터베이스 설계자 (Database Designer)

- 오퍼레이터 (Operator)

-----

## 관계 데이터 모델의 개념

- 기본적인 용어

![릴레이션의예1](./imege/릴레이션의예1.png)

관계 데이터 모델에서 릴레이션(Relation)은 2차원의 테이블을 의미한다. 이 모델에서 정보는 행(Row)과 열(Column)들로 표현된다. 릴레이션의 각 행을 레코드라 부르며, 레코드를 좀 더 공식적으로 튜플(Tuple)이라 한다. 애트리뷰트(Attribute)는 릴레이션에서 이름을 가진 하나의 열이다. 도메인은 한 애드리뷰트에 나타날 수 있는 값들의 집합을 의미하며, 관계 데이터 모델에서 복합 애트리뷰트나 다치 애드리뷰트는 혀옹되지 않으며 이를 제 1 정규형이라 한다.

한 릴레이션에 들어 있는 애트리뷰트의 수를 차수라하며, 최소 1 차수를 가져야한다. 모든 릴레이션은 적어도 한 개의 애트리뷰트를 가져야 하며, 릴레이션의 튜플 수를 카디날리티라 한다. 카디날리티는 0을 가질 수 있다.

릴레이션의 이름과 릴레이션의 애트리뷰트들의 집합을 릴레이션 스키마(Relation Schema)라 한다. 스키마는 릴레이션을 위한 틀(Framework)이다. 릴레이션 인스턴스(Relation Instance)는 릴레이션에 어느 시점에 들어 있는 튜플들의 집합이다. 릴레이션 스키마를 내포(Intension)라하며, 릴레이션 인스턴르를 외연(Extension)이라 한다. 내포는 데이터 정의어를 사용하여 정의한다.

![릴레이션의예2](./imege/릴레이션의예2.png)

### 릴레이션 특징

- 오직 하나이 레코드 타입만 포함한다.
- 한 애트리뷰트 애의 값은 모두 같은 유형이다.
- 애트리뷰트들의 순서는 중요하지 않다.
- 릴레이션은 튜플의 집합이며, 동일한 튜플이 두 개 이상 존재하지 않는다.
- 한 튜플의 각 애트리뷰트는 원자값을 갖는다.
- 튜플의 순서는 중요하지 않다.
- 각 애트리뷰트의 이름은 한 릴레이션 내에서만 고유하다.



### 릴레이션 키

릴레이션의 키는 각 튜플을 고유하게 식별할 수 있는 하나 이상의 애트리뷰트의 모임이다. 일반적으로 키는 두 릴레이션을 서로 연관시키는 데 사용돈다. 한 릴레이션의 어떤 키의 값이 다른 릴레이션에 나타나면 두 릴레이션이 해당 튜플들이 서로 연관되었음을 알 수 있다. 따라서 여러 릴레이션에 불필요하게 애트리뷰트 값들이 중복되는 것을 피하기 위해 가능하면 키를 구성하는 애트리뷰트 수사 적을수록 좋다.릴레이션의 튜블들을 접근하는 속도를 높이기 위해 키에 인덱스를 만드는데, 키가 작을수록 인덱스의 크기가 줄어들고 인덱스를 검색하는 시간이 단축된다.

- 수퍼 키 (Super Key)

  한 릴레이션 내의 특정 튜플을 고유하게 식별하는 하나의 애트리뷰트 또는 애트리뷰트들의 집합이다.

- 후보 키 (candidate Key)

  각 튜플을 고유하게 식별하는 최소한의 애트리뷰트들의 모임이다. 후보 키를 구성하는 애트리뷰트들 둥에서 어느 한 애트리뷰트라도 빼면 고유하게 식별하는 능력을 상실한다. 후보 키도 두 개 이상의 애트리뷰트로 이루어질 수 있으며 이런 경우에 복합 키(Composite Key)라 한다.

- 기본 키 (Primary Key)

  한 릴레이션에 후보 키가 두 개 이상 있으면 데이터베이스 설계자 또는 데이터베이스 관리자가 이들 중 하나를 기본 키로 선정한다. 후보 키가 한 개 밖에 없으면 당연이 이 후보 키가 기본 키가 된다. 자연스러운 기보 키를 찾을수 없는 경우에는 레코드 번호와 같이 종종 인위적인 키 애트리뷰트를 릴레이션에 추가한다. 이런 키를 대리 키(Surrogate Key)라 한다.

  대체 키 (Alternate Key)

  기본 키로 선정되지 않은 후보 키를 말한다.

- 외래 키 (Foreign Key)

  어떤 릴레이션의 기본 키를 참조하는 애트리뷰트이다. 외래 키는 관계 데이터베이스에서 릴레이션 간의 관계를 나타내기 위해 사용된다.


-----

## 무결성 제약조건

데이터 무결성(Data Integrity)은 데이터의 정확성 또는 유효성을 의미한다. 무결성 제약조건의 목적은 일관된 데이터베이스 상태를 정의하는 규칙들을 묵시적으로 또는 명시적으로 정의하는 것이다. 프로그램 언어에서 규칙은 서로 다른 데이터 타입의 데이터를 비교하거나 어떤 데이터 타입의 변수에 다른 데이터 타입의 변수를 배정하는 등의 작업을 제한한다. 이는 사용자가 일반적으로 무의미한 작업을 하지 못하도록 하기 위한 것이다. DBMS에서 무결성 제약조건은 비슷한 역할을 한다. 데이터베이스 무결성은 권한을 가진 사용자들로부터 데이터베이스의 정확성을 지키는 것이다. 무결성 제약조건은 데이터베이스 상태가 만족시켜야 하는 조건이다. 사용자에 의한 데이터베이스 갱신이 데이터베이스의 일관성를 깨지 않도록 보장하는 수단이다.

- 도메인 제약조건 (Domain Constraint)

  가장 간단한 형태의 제약조건으로, 각 애트리뷰트 값이 반드시 원자값이어야 한다. 데이터 형식을 통해 값들의 유형(정수형, 실수형, 문자형 등)을 제한하고, 애트리뷰트의 디폴트 값을 지정하고, 애트리뷰트에 저장되는 값들의 범위를 제한할 수 있다. 릴레이션을 정의할 때 애트리뷰트 선언에 'NOT NULL' 구문을 붙이면 모든 튜플에서 해당 애트리뷰트의 값이 존재하도록 보장한다.

- 키 제약조건 (Key Constraint) 

  키 애트리뷰트에 중복된 값이 존재해서는 안된다는 것을 의미한다. 릴레이션을 정의할 때 기본 키로 정의하거나 UNIQUE를 명시한 애트리뷰트에는 중복된 값이 허용되지 않는다.

- 기본 키와 엔티티 무결성 제약조건 (Entity Integrity Constraint)

  기본 키는 튜플들을 고유하게 식별하고, 효율적으로 빠르게 접근하는데 사용된다. 두 개 이산의 튜플이 동일한 기본 키 값을 가질 수 없다. 기본 키를 구성하는 애트리뷰트가 널 값을 가지면 튜플들을 고유하게 식별할 수 없게 되므로 엔티티 무결성 제약조건은 릴레이션의 기본 키를 구성하는 어떤 애트리뷰트도 널 값을 가질수 없다는 것이다.

- 외래 키와 참조 무결성 제약조건 (Referential Integrity Constraint)

  참조 무결성 제약조건은 두 릴레이션의 연관된 튜플들 사이의 일관성을 유지하는데 사용된다. 관계 데이터베이스가 포인터 없이 오직 릴레이션들로만 이루어지고, 릴레이션의 사이의 관계들이 다른 릴레이션의 기본 키를 참조하는 것을 기반으로하여 묵시적으로 표현되기 때문에 외래키의 개념이 중요하다. 릴레이션 R2의 외래 키가 릴레이션 R1의 기본 키를 참조할 때 참조 무결성 제약조건은 다름의 두 조건 중 하나가 성립되면 만족한다.

  - 외래 키의 값은 R1의 어떤 튜플의 기본 키 값과 같다.
  - 외래 키가 자신을 포함하고 있는 릴레이션의 기본 키를 구성하고 있지 않으면널 값을 가진다.


-----

## 조인 연산자

조인 연산자는 두 개의 릴레이션으로부터 연관된 튜플들을 결합하는 연산자이다. 이 연산자는 관계 데이터베이스에서 두 개 이상의 릴레이션들의 관계를 다루는데 매우 중요한 연산자이다. 결과만 비교한다면 조인 연산자는 카티션 곱을 실행한 후 실렉션을 적용한 것과 같다. 조인 연산자는 시간이 오래 걸리는 연산자이므로 조인을 효율적으로 수행하는 여러 가지 알고리즈들이 개발되었다. 세타 조인(θ-Join), 동등 조인(Equi Join), 자연 조인(Natural Join), 외부 조인(Outer Join), 세미 조인(Semi Join) 등이 있다.

- 세타 조인과 동등 조인

  세타 조인을 수행하기 위해서 양쪽 릴레이션의 애트리뷰트들이 세타 조인 조건을 만족하는 튶플들만 골라낸다. 이것이 카티션 곱과 조인의 주요 차이점이다. 동등 조인에서는 두 릴레이션에서 조인 조건에 사용된 두 애트리뷰트가 결과 릴레이션에 포함된다.

- 자연 조인

  동등 조인의 결과 릴레이션에서 조인 애트리뷰트를 한 개 제외한 것을 자연 조인이라고 한다. 자연 조인은 여러 가지 조인 연산자들 중에서 가장 자주 사용되며, 실제 관계 데이터베이스에서 대부분의 질의는 실렉션, 프로젝션, 자연 조인으로 표현 가능하다.

- 외부 조인

  상대 릴레이션에서 대응되는 튜플을 갖지 못하는 튜플이나 조인 애트리뷰트에 널 값이 들어있는 튜플들을 다루기 위해서 조인 연산을 확장한 것이다. 외부 조인은 두 릴레이션에서 대응되는 튜플들을 결합하면서, 대응되는 튜플을 갖지 않는 튜플과 조인 애트리뷰트에 널 값을 갖는 튜플도 결과에 포함시킨다.

  - 왼쪽 외부 조인 (Left Outer Join)

    릴레이션 R과 S의 왼쪽 외부 조인 연산은 R의 모든 튜플들을 결과에 포함하시고, 만일 릴레이션 S에 관련된 튜플이 없으면 결과 릴레이션에서 릴레이션 S의 애트리뷰트들은 널값을 채운다.

    ​

    R

    | A    | B    | C    |
    | ---- | ---- | ---- |
    | a1   | b1   | c1   |
    | a2   | b2   | c3   |

    S

    | C    | D    | E    |
    | ---- | ---- | ---- |
    | c1   | d1   | e1   |
    | c3   | d2   | e2   |

    RESULT

    | A    | B    | C    | D    | E    |
    | ---- | ---- | ---- | ---- | ---- |
    | a1   | b1   | c1   | d1   | e1   |
    | a2   | b2   | c2   | null | Null |


  - 오른쪽 외부 조인 (Right Outer Join)

    릴레이션 R과 S의 오른쪽 외부 조인 연산은 S의 모든 튜플들을 결과에 포함시키고, 만일 릴레이션 R에 관련된 튜플이 없으면 결과 릴레이션에서 릴레이션 R의 애트리뷰트들은 널 값으로 채운다.

    R

    | A    | B    | C    |
    | ---- | ---- | ---- |
    | a1   | b1   | c1   |
    | a2   | b2   | c3   |

    S

    | C    | D    | E    |
    | ---- | ---- | ---- |
    | c1   | d1   | e1   |
    | c3   | d2   | e2   |

    RESULT

    | A    | B    | C    | D    | E    |
    | ---- | ---- | ---- | ---- | ---- |
    | a1   | b1   | c1   | d1   | e1   |
    | null | null | c3   | d2   | e2   |

  - 완전 외부 조인 (Full Outer Join)

    릴레이션 R과 S의 완전 외부 조인 연산은 R과 S의 모든 튜플들을 결과에 포함시키고, 만일 상대 릴레이션에 관련된 튜플이 없으면 결과 릴레이션에서 상대 릴레이션의 애트리뷰트들은 널 값으로 채운다.

    R

    | A    | B    | C    |
    | ---- | ---- | ---- |
    | a1   | b1   | c1   |
    | a2   | b2   | c3   |

    S

    | C    | D    | E    |
    | ---- | ---- | ---- |
    | c1   | d1   | e1   |
    | c3   | d2   | e2   |

    RESULT

    | A    | B    | C    | D    | E    |
    | ---- | ---- | ---- | ---- | ---- |
    | a1   | b1   | c1   | d1   | e1   |
    | A3   | b2   | c2   | null | null |
    | null | null | c3   | d2   | e2   |

#### Ex.

```Sql
create table group1 (
			id varchar(250),
			serial integer,
			dept integer,
			constraint PK_DEPT primary key(dept));

create table group2 (
			name varchar(250),
			password varchar(150),
			dept integer,
			constraint dept foreign key(dept) references group1(dept));

insert into group1 values('a', 1,1);
insert into group1 values('b', 2,2);
insert into group1 values('c', 3,3);

insert into group2 values('aaa', 'aaa', 1);
insert into group2 values('bbb', 'bbb', 2);
```

```sql
select * from group1 g1 left outer join group2 g2 on g1.dept = g2.dept;
```

|  Id  | serial | dept | name | passwoard | dept |
| :--: | :----: | :--: | :--: | :-------: | :--: |
|  a   |   1    |  1   | aaa  |    aaa    |  1   |
|  b   |   2    |  2   | bbb  |    bbb    |  2   |
|  c   |   3    |  3   | null |   null    | null |

(3 rows)

```sql
select * from group1 g1 rigth outer join group2 g2 on g1.dept = g2.dept;
```

|  Id  | serial | dept | name | password | dept |
| :--: | :----: | :--: | :--: | :------: | :--: |
|  a   |   1    |  1   | aaa  |   aaa    |  1   |
|  b   |   2    |  2   | bbb  |   bbb    |  2   |

(2 rows)

```sql
select * from group1 g1 full outer join group2 g2 on g1.dept = g2.dept;
```

| Id   | serial | dept | name | password | dept |
| ---- | ------ | ---- | ---- | -------- | ---- |
| a    | 1      | 1    | aaa  | aaa      | 1    |
| b    | 2      | 2    | bbb  | bbb      | 2    |
| c    | 3      | 3    | null | null     | null |

(3 rows)

-----

## SQL (Structured Query Language)

자연어에 가까운 구문을 사용하여 질의를 표현할 수 있는 SQL은 비절차적 언어이며 선언적 언어라고도 표현한다. 사용자는 자신이 원하는 데이터(What)만 명시하며, 원하는 것을 처리하는 방법(How)은 명시할 수 없다. 이 점이 SQL이 상대적으로 배우기 쉬운 언어가 되도록 하는 중요한 요인이다. 또한 SQL은 관계적으로 완전하고, 릴레이션을 정렬하고, 중복된 튜플들을 허용할 수 있기 때문에 관계 대수나 관계 해석보다 표현력이 우수하다.

-----

## 인덱스 (Index)

인덱스는 DBMS가 파일 내의 특정 레코드들을 빠르게 찾을 수 있도록 하는 데이터 구조이므로 인덱스를 통하여 질의를 수행하면 응답 시간이 향상된다. 디스크 접근 시간이 주기억 장치 접근 시간에 비해서 매우 크고 대부분의 데이터베이스 응용에서 디스크 접근을 많이 요구하므로, 인덱스를 통해 디스크 접근 횟수를 줄이면 데이터베이스의 성능을 크게 향상시킬 수 있다. 

인덱스는 임의 접근을 필요로 하는 응용에 적합하다. 인덱스는 데이터 파일과는 별도의 파일에 저장되며, 데이터 파일이 들어있는 여러 애트리뷰트 중 탐색 키에 해당하는 일부 애트리뷰트만 인덱스에 포함되기 때문에 인덱스의 크기는 데이타 파일의 크기에 비해 훨씬 작다. 또한 하나의 파일에 여러개의 인덱스를 정의할 수 있다.

인덱스가 정의된 필드를 탐색 키라고 부른다. 탐색 키의 값들은 후보 키처럼 각 튜플마다 반드시 고유하지는 않다. 후보 키와 달리 두 개 이상의 튜플들이 동일한 탐색 키 값을 가질 수 있으며, 키를 구성하는 애트리뷰트뿐만 아니라 어떤 애트리뷰트도 탐색 키로 사용될 수 있다.

인덱스가 데이터 파일보다 크기가 작으므로 인덱스를 순차적으로 찾는 시간은 데이터 파일을 순차적으로 탐색하는 시간보다 적게 걸린다. 인덱스의 엔트리는 탐색 키 값의 오름차순으로 저장되어 있으므로 이진 탐색을 이용할 수 있다. 이진 탐색을 이용하면 탐색 시간이 훨씬 적게 소요된다. 인덱스를 사용하면 한 파일에서 특정 레코드를 찾기 위해 모든 레코드들을 탐색할 필요가 없으므로 파일이 매우 클 경유 유용하다. 인덱스 전체를 주기억 장치에 유지할수 있는 때 인덱스가 성능에 도움이 된다. 어떤 레코드를 찾는 질의도 한 번의 디스크 접근만 필요로 한다.

인덱스는 크게 단일 단계 인덱스와 다단계 인덱스로 나뉘며, 단일 단계 인덱스에는 기본 인덱스(Primary Index), 클러스터링 인덱스(Clustering Index), 보조 인덱스(Secondary Index), 회소 인덱스(Sparse Index), 밀집 인덱스(Dense Index)등이 있다. 단일 단계 인덱스는 인덱스가 정의된 필드의 값에 따라 정렬된 파일로 볼수 있으며, 인덱스 자체가 클 경우에는 인덱스를 탐색하는 시간도 오래 걸리기 때문에 인덱스 엔트리를 탐색하는 시간을 줄이기 위해 단일 단계 인덱스를 디스크 산의 하나의 순서 파일로 간주하고 단일 단계 인덱스에 대해 다시 인덱스를 정의한다. 이를 다단계 인덱스라 한다.

-----

## 릴레이션 정규화

정규화(Normalization)는 관계 데이터베이스 스키마를 기반으로 릴레이션의 수학적인 이론을 적용하여 보다 좋은 데이터베이스 설계로 이끄는 상향식 방법론이다. 적절하게 정규화된 릴레이션은 데이터베이스의 유지를 간단하게 한다. 하나의 릴레이션을 좀 더 단순하고 바람직한 구조를 갖는 두 개 이상의 릴레이션으로 쪼개는 과정을 정규화라 하며, 정규화는 정규화되지 않은 릴레이션을 보다 좋은 구조를 갖는 릴레이션들로 단계적으로 변환해 가는 과정이다.

정규형(Normal Form)에는 제 1 정규형(First Normal Form), 제 2 정규형(Second Normal Form), 제 3 정규형(Third Normal Form), BCNF(Boyce-Cold Normal Form), 제 4 정규형(Fourth Normal Form), 제 5 정규형(Fifth Normal Form)등이 있다.

-----

## 함수적 종속성

함수적 종속성(F: Functional Dependency)의 개념은 정규화 이론의 핵심이다. 함수적 종속성은 관계 데이터 모델에서 가자 중요한 제약 조건의 하나이다. 함수적 종속성에 관한 지식은 갱신 이상과 중복을 제거하기 위해 데이터베이스 스키마를 설계하는데 필수적이다. 함수적 종속성은 릴레이션의 애트리뷰트의 의미로부터 결정되며, 릴레이션의 가능한 모든 인스턴스들이 만족해야 한다. 어떤 릴레이션 인스턴스가 주어졌을 때 이 인스턴스가 어떤 함수적 종속성을 위반하는지 검사할 수 있지만 함수적 종속성이 모든 릴레이션 인스턴스에서 성립하는지는 알수 없다. 함수적 종속성 제약조건을 만족하는 릴레이션의 인스턴스를 합법적인 인스턴스라 한다.

-----

## 정규형 (Normal Form)

- 제 1 정규형 (First Normal Form)

  한 릴레이션 R이 제 1 정규형을 만족할 필요충분조건은 릴레이션 R의 모든 애트리뷰트가 원자값만을 갖아냐 한다. 즉 릴레이션의 모든 애트리뷰트에 반복 그룹(Repeating Group)이 나타나지 않으면 제 1 정규형을 만족한다.

- 제 2 정규형 (Second Normal Form)

  제 2 정규형을 만족할 필요충분조건은 릴레이션의 모든 애트리뷰트가 원자값을 가지는 제 1 정규형을 만족하고, 어던 후보 키에도 속하지 않는 모든 애트리뷰트들이 R의 기본 키에 완전하게 함수적으로 종속하는 것이다.

- 제 3 정규형 (Third Normal Form)

  제 3 정규형을 만족할 필요충분조건은 릴레이션이 제 2 정규형을 만족하고, 키가 아닌 모든 애트리뷰트가 릴레이션의 기본 키에 이행적으로 종속하지 않는 것이다.

- BCNF

  한 릴레이션이 BCNF를 만족할 필요충분조건은 릴레이션이 제 3 정규형을 만족하고, 모든 결정자가 후보 키여야만 한다. 제 3 정규형을 만족하는 대부분의 릴레이션들은 BCNF도 만족한다.

-----

## 역정규화

정규화가 데이터베이스 설계의 중요한 요소이지만 높은 정규형이 항상 최선이라는 생각은 옳지 않다. 성능상의 관점에서만 본다면 높은 정규형을 만족하는 릴레이션 스키마가 최선인 것은 아니다. 정규형이 진행될 때마나 하나의 릴레이션은 최소한 두 개의 릴레이션으로 분해된다. 분해된 릴레이션을 대상으로 질의를 할 때 같은 정보를 얻기 위해서 보다 많은 릴레이션을 접근해야 하므로 조인의 필요성이 증가한다.

역정규화(Denormalization)는 주어진 응용에서 빈번하게 수행되는 검색 질의의 수행 속도를 높이기 위해서 이미 분해된 두 개 이상의 릴레이션들을 합쳐서 하나의 릴레이션으로 만드는 작업이다. 즉 역정규화는 보다 낮은 정규형으로 되돌아가는 것이다.

-----

## 트랜잭션

하나의 트랜잭션처럼 DBMS가 보장해야 한다.

트랜잭션은 일종의 단위이다.

DBMS는 사용자가 입력하는 SQL문 중 어떤 것을 하나의 트랜잭션으로 취급해야 하는지 알 수 없으며, 기본적으로 각각의 SQL문이 하나의 트랜잭션으로 취급된다. 두 개 이상의 SQL문을 하나의 트랜잭션으로 취급하려면 사용자가 이를 명식적으로 표시해야 한다.

트랜잭션은 데이터베이스 시스템에서 매우 중요한 개념으로, 네 가지 특성을 만족해야 한다. 이를 ACID 특성이라 한다.

- 원자성 (Atomicity)

  원자성은 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음(All or Nothing)을 의마한다.

- 일관성 (Consistency)

  한 트랜잭션을 정확하게 수행하고 나면 데이터베이스가 하나의 일관성 상태에 다른 일관된 상태로 바뀐다. 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 갖는다.

- 고립성 (Isolation)

  한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션이 접근하지 못하도록 해야한다. 고립성은 다수의 트랜잭션이 동시해 수행되는 것을 다룬다. 즉 각 트랜잭션은 시스템 내에서 동시에 수행되고 있는 다른 트랜젝션을 알지 못한다. 다수의 트랜잭션이 동시에 수행되더라도 그 결과는 어떤 순서에 따라 트랜잭션을 하나씩 차례대로 수행한 결과와 같아야 한다.

- 지속성 (Durability)

  한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않는다. 완료된 트랜잭션의 효과는 시스템이 고장난 경우에도 데이터베이스에 반영된다. DBMS의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장한다.

-----

## 로킹 (Locking)

데이터 항목을 로킹하는 개념은 동시에 수행되는 트랜잭션의 동시성을 제어하기 위해 가장 널리 사용되는 기법이다. 동일한 데이터 항목에 대한 여러 트랜잭션의 동시 접근을 조정하기 위해 로크(Lock)가 사용된다. 로크는 데이터베이스 내에 각 데이터 항목과 연관된 하나의 변수이다. 일반적으로 데이터베이스 내의 모든 데이터 항목마다 로크가 존재한다. 각 트랜잭션의 수행을 시작하여 데이터 항목을 접근할 때마다 요청한 로크에 관한 정보는 로크 테이블(Lock Table) 등에 유지된다.

-----

## 체크포인트 (Checkpoint)

DBMS는 시스템이 다운된 후 재가동 되었을 때 [Trans-ID, start] 로그 레코드와 [Trans-ID, commit] 로그 레코드가 모두 디스크의 로그에 존재하면 이 트랜잭션을 재수행하고, [Trans-ID, commit] 로그 레코드가 존재하지 않는 트랜잭션은 취소한다. 시스템이 다운되기 직전에 완료된 트랜잭션이 데이터베이스를 갱신한 내용은 주기억 장치의 버퍼에 남아 있으면서 아직 디스크에 기록되지 않았을 가능성이 높으므로 로드 레코드를 보고 트랜잭션의 갱신 사항을 재수행해야 하지만 시스템이 다운된 시점으로부터 오래 전에 완료된 트랜잭션이 테이터베이스를 갱신한 사항은 이미 디스크에 반영되었을 것이다. 이런 트랜잭션을 재수행하는 것은 불가능하다.













